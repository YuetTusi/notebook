
## 数组

go语言中数组、切片类型方括号要写在类型前面。

### 定义数组

```go
var arr1 = [3]int //[0,0,0]
arr2 := [3]int{1,2,3} //[1,2,3] 短声明必须初始化
arr3 := [...]int{1,2,3} //[1,2,3] 省略数组长度写法
```

数组定义要明确其长度，如果想省略长度，必须使用3点号`...`，如果不写这3个点号go编译器会认为是切片类型，这一点要注意。

数组声明之后要赋初值，否则每个元素都是类型的**零值**

### 长度和容量

go语言内置了两个函数来获取数组的长度和容量：

```go
    arr1 := [...]int{1, 2, 3}
    fmt.Printf("arr1 长度：%d，容量：%d\n", len(arr1), cap(arr1))
    arr2 := [...]string{"h", "e", "l", "l", "o"}
    fmt.Printf("arr2 长度：%d，容量：%d\n", len(arr2), cap(arr2))
```
结果：
```bash
arr1 长度：3，容量：3
arr2 长度：5，容量：5
```

内置函数`len()`用于获取数组的长度；`cap()`获取容量。

### 遍历

遍历数组除了使用for循环，go还提供了一个range关键字用于自动遍历数组、切片等类型，更加方便：

```go
    var s = [3]int{99, 87, 62}
    for i, v := range s {
        fmt.Printf("s[%d]=%d ", i, v)
    }
```
结果：
```bash
s[0]=99 s[1]=87 s[2]=62 
```

其中i用于取下标，v为当前下标对应的值。如果只想取其中一个，如只遍历值，则使用`_`来告诉go忽略下标取值；

```go
for _, v := range s {
 //只取值
}
```

go语言中数组是**值类型**，函数传参若为数组类型时，为值拷贝。

```go
func main() {
    var s = [3]int{11, 22, 33}
    r := mapScore(s)
    fmt.Println(s) //[11 22 33]
    fmt.Println(r) //[21 32 43]
}

func mapScore(s [3]int) [3]int {
    for i, v := range s {
        s[i] = v + 10 //每个元素值+10
    }
    return s
}
```

以上代码mapScore函数接收一个数组类型，注意`[3]int`的长度3不可省略，否则是一个切片类型。内部将每个数组元素值加10，并返回结果。

调用函数后，可以看到不会修改s数组的原数据，**数组在go语言中是值类型**。

如果想要达到修改原数组的目的，则函数参数要改为指针类型。

## 切片

go语言中更多的使用是切片，它相对于数组更加灵活，因为存放数据不会预先定义长度，随着数据的增加，也会由go自动扩容。

而数组在go语言中是切片背后的“底层数据“，操作切片就是在操作其底层对应的“数组”。

### 定义切片

```go
    var s1 = []int{1, 2, 3} //[1 2 3]
    s2 := []string{"O", "K"} //[O K]
```

和数组几乎一样，定义切片的区别只是不必在方括号中写上长度。

由于切片的底层是数组，因此可以方便的从一个现有的数组中定义切片：

```go
	a := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} //定义一个10个元素数组
	s1 := a[2:6] //左开右闭 [2,3,4,5]
	s2 := a[:6]  //从开始切到下标6前[0,1,2,3,4,5]
	s3 := a[2:]  //从下标2开始切到末尾[2,3,4,5,6,7,8,9]
	s4 := a[:]   //取全部数组[0,1,2,3,4,5,6,7,8,9]
	s5 := a[2:50] //编译报错，越界
```

以上从a数组中定义了4个切片类型，可以使用`[m:n]`这种语法灵活的从现有数组中取数据来生成一个切片类型。

> 从数组中定义新的切片，下标不可越界，否则编译不能通过。

还可以从现有的切片中再次定义切片。

```go
a := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

s1 := a[2:6]  //[2,3,4,5]
s2 := s1[3:4] //[5]
s3 := s1[3:5] //[5,6]
s4 := s1[3:9] //运行报错，越界
```

以上s2，s3，s4切片都是从s1中再次创建。但本质还是从底层数组a中取出的数据。

当s1取a数组的[2:6]元素，此时s1为[2,3,4,5]。

s2再取s1的[3:4]元素，此时s2为[5]

s3再取s1的[3,:5]元素，此时s3为[5,6]（虽然下标6越过了s1的长度，但底层数组仍有值，可取到）

s4再取s1的[3:9]元素，运行报错（底层数组只能取到8，因此越界了）

从此代码示例中可以看出，切片只是底层数组的一个“视图”，操作数据都是在操作底层的数组而已。

操作

向切片中增加数据使用内置函数`append()`：

```go
var s []int
s = append(s, 10, 20, 30) //[10 20 30]
```

append参数1为操作的切片，参数2为增加的数据，是可变参数，返回增加后的切片。

### 删除

删除切片中的数据没有内置函数直接可以使用，但可以使用append函数巧妙的实现删除。

如现在有一个以下数据的切片：[0,1,2,3,4,5]，目的想要删除值为4的元素（下标为4）：

```go
s := []int{0, 1, 2, 3, 4, 5}
s = append(s[:4], s[5:]...) //[0 1 2 3 5]
```

通过对s切片的再次提取，从0切到4，从5切到切片最后一个值，这样能能把下标为4的数据删除。

`...`点号在此处意为把切片展开。


## Map

Map使用键值对结构来组织数据，内部通过哈希算法实现，因此Map中存取数据非常快。

定义Map数据要明确键和值的类型：

```go
    var score = make(map[string]int)
    score["Tom"] = 63
    score["Jack"] = 75
    score["Kate"] = 88
```

内置的`make`函数也可以声明Map结构，之后便可以按数据类型为score赋值。

也可以用更方便的方式：

```go
	score := map[string]int{
		"Tom":  63,
		"Jack": 75,
		"Kate": 88,
	}
```

使用内置的`len()`函数可以取得Map中键值的数量。

### 遍历

Map结构也可以遍历，但由于它是无序的，因此不能保证每一次遍历都是相同的顺序：

```go
	score := map[string]float32{
		"小明": 60.5,
		"小红": 75,
		"小强": 90,
	}

	for k, v := range score {
		fmt.Printf("%s ", k) //键
		fmt.Printf("%v \n", v) //值
	}
```

多运行几次就可以发现，每次输出的结果顺序都不一样，这就是Map结构的特点。

### 取值

取某一个键值使用方括号键名的方式，当试图从Map取出一个没有的键值时，返回其类型的“零值”：

```go
	test1 := map[string]bool{}
	test2 := map[string]int{}
	test3 := map[string]string{}

	fmt.Println(test1["a"]) //false
	fmt.Println(test2["a"]) //0
	fmt.Println(test3["a"]) //""
```

为了判断一个Map中有没有存在的键值，可以在取值时使用第2个返回值。第2返回一个布尔值，当为false表示Map中无此键

```go
list := map[string]int{
	"Tom": 66,
}

s1, exist1 := list["Tom"]
fmt.Printf("是否存在：%v, 值：%v\n", exist1, s1) //是否存在：true, 值：66
s2, exist2 := list["Jack"]
fmt.Printf("是否存在：%v, 值：%v\n", exist2, s2) //是否存在：false, 值：0
```

### 删除

删除Map中的键使用`delete`内置函数：

```go
	score := map[string]int{
		"Tom":  66,
		"Jack": 75,
	}

	delete(score, "Tom") //删除Tom的键
```

参数1为操作的Map，参数2为要删除的键名。

Go语言中，Map类型的键必须唯一；键的类型可以是除slice，map，function外的任意类型。
