
## 数组

go语言中数组、切片类型方括号要写在类型前面。

### 定义数组

```go
var arr1 = [3]int //[0,0,0]
arr2 := [3]int{1,2,3} //[1,2,3] 短声明必须初始化
arr3 := [...]int{1,2,3} //[1,2,3] 省略数组长度写法
```

数组定义要明确其长度，如果想省略长度，必须使用3点号`...`，如果不写这3个点号go编译器会认为是切片类型，这一点要注意。

数组声明之后要赋初值，否则每个元素都是类型的**零值**

### 长度和容量

go语言内置了两个函数来获取数组的长度和容量：

```go
    arr1 := [...]int{1, 2, 3}
    fmt.Printf("arr1 长度：%d，容量：%d\n", len(arr1), cap(arr1))
    arr2 := [...]string{"h", "e", "l", "l", "o"}
    fmt.Printf("arr2 长度：%d，容量：%d\n", len(arr2), cap(arr2))
```
结果：
```bash
arr1 长度：3，容量：3
arr2 长度：5，容量：5
```

内置函数`len()`用于获取数组的长度；`cap()`获取容量。

### 遍历

遍历数组除了使用for循环，go还提供了一个range关键字用于自动遍历数组、切片等类型，更加方便：

```go
    var s = [3]int{99, 87, 62}
    for i, v := range s {
        fmt.Printf("s[%d]=%d ", i, v)
    }
```
结果：
```bash
s[0]=99 s[1]=87 s[2]=62 
```

其中i用于取下标，v为当前下标对应的值。如果只想取其中一个，如只遍历值，则使用`_`来告诉go忽略下标取值；

```go
for _, v := range s {
 //只取值
}
```

go语言中数组是**值类型**，函数传参若为数组类型时，为值拷贝。

```go
func main() {
    var s = [3]int{11, 22, 33}
    r := mapScore(s)
    fmt.Println(s) //[11 22 33]
    fmt.Println(r) //[21 32 43]
}

func mapScore(s [3]int) [3]int {
    for i, v := range s {
        s[i] = v + 10 //每个元素值+10
    }
    return s
}
```

以上代码mapScore函数接收一个数组类型，注意`[3]int`的长度3不可省略，否则是一个切片类型。内部将每个数组元素值加10，并返回结果。

调用函数后，可以看到不会修改s数组的原数据，**数组在go语言中是值类型**。

如果想要达到修改原数组的目的，则函数参数要改为指针类型。

## 切片

go语言中更多的使用是切片，它相对于数组更加灵活，因为存放数据不会预先定义长度，随着数据的增加，也会由go自动扩容。

而数组在go语言中是切片背后的“底层数据“，操作切片就是在操作其底层对应的“数组”。

### 定义切片

```go
    var s1 = []int{1, 2, 3} //[1 2 3]
    s2 := []string{"O", "K"} //[O K]
```

和数组几乎一样，定义切片的区别只是不必在方括号中写上长度。

由于切片的底层是数组，因此可以方便的从一个现有的数组中定义切片：

```go
	a := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9} //定义一个10个元素数组
	s1 := a[2:6] //左开右闭 [2,3,4,5]
	s2 := a[:6]  //从开始切到下标6前[0,1,2,3,4,5]
	s3 := a[2:]  //从下标2开始切到末尾[2,3,4,5,6,7,8,9]
	s4 := a[:]   //取全部数组[0,1,2,3,4,5,6,7,8,9]
	s5 := a[2:50] //编译报错，越界
```

以上从a数组中定义了4个切片类型，可以使用`[m:n]`这种语法灵活的从现有数组中取数据来生成一个切片类型。

> 从数组中定义新的切片，下标不可越界，否则编译不能通过。

还可以从现有的切片中再次定义切片。

```go
a := [10]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

s1 := a[2:6]  //[2,3,4,5]
s2 := s1[3:4] //[5]
s3 := s1[3:5] //[5,6]
s4 := s1[3:9] //运行报错，越界
```

以上s2，s3，s4切片都是从s1中再次创建。但本质还是从底层数组a中取出的数据。

当s1取a数组的[2:6]元素，此时s1为[2,3,4,5]。

s2再取s1的[3:4]元素，此时s2为[5]

s3再取s1的[3,:5]元素，此时s3为[5,6]（虽然下标6越过了s1的长度，但底层数组仍有值，可取到）

s4再取s1的[3:9]元素，运行报错（底层数组只能取到8，因此越界了）

从此代码示例中可以看出，切片只是底层数组的一个“视图”，操作数据都是在操作底层的数组而已。

